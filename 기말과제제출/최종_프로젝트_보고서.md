# 실습실 시간표 자동 배정 시스템
## 최종 프로젝트 보고서

---

**작성일**: 2024년  
**프로젝트명**: AI 기반 실습실 시간표 자동 배정 시스템  
**개발 목적**: 실습 시설의 운영 효율성과 수익성 제고를 위한 공실 최소화 및 시간표 최적화

---

## 목차

1. [요약](#1-요약)
2. [서론](#2-서론)
3. [시스템 아키텍처](#3-시스템-아키텍처)
4. [시간표 자동 배정 알고리즘](#4-시간표-자동-배정-알고리즘)
5. [주요 기능](#5-주요-기능)
6. [구현 세부사항](#6-구현-세부사항)
7. [테스트 및 검증](#7-테스트-및-검증)
8. [결론 및 향후 계획](#8-결론-및-향후-계획)
9. [참고 자료](#9-참고-자료)

---

## 1. 요약

본 프로젝트는 실습실 및 실습센터의 시간표를 자동으로 배정하고, 공실을 효율적으로 활용하기 위한 AI 기반 시스템을 개발하는 것을 목표로 한다. 유전 알고리즘(Genetic Algorithm)을 활용하여 공실을 최소화하는 최적의 시간표를 자동 생성하며, 학과 요구사항 및 교수 일정에 대한 예외 사항을 최종적으로 조정할 수 있는 기능을 제공한다.

### 1.1 핵심 성과

- **공실 최소화 알고리즘 구현**: 유전 알고리즘 기반으로 강의실 활용률 극대화
- **시간대 다양성 확보**: 모든 시간대(09:00-18:00)를 균등하게 활용하는 배정 달성
- **실시간 재배정 기능**: 강의 추가/삭제 시 전체 시간표를 처음부터 재최적화
- **버전 관리 시스템**: 모든 변경 이력을 저장하고 이전 버전으로 롤백 가능
- **직관적인 웹 인터페이스**: HTML/CSS/JavaScript 기반의 사용자 친화적 UI

### 1.2 기술 스택

- **백엔드**: Python 3.x, FastAPI 0.104.1
- **프론트엔드**: HTML5, CSS3, JavaScript (Vanilla JS)
- **데이터베이스**: SQLite (SQLAlchemy ORM)
- **주요 라이브러리**: Pandas, Uvicorn

### 1.3 주요 개선 사항

- **공실 페널티 강화**: -10 → -30 (3배 증가)
- **강의실-요일별 공실 집중도 페널티 추가**: 특정 강의실의 특정 요일에 공실이 집중되는 것을 방지
- **강의실-요일별 활용률 보너스**: 각 강의실-요일 조합의 높은 활용률에 보너스 부여
- **3시간 블록 공실 보너스**: 정확히 3시간 블록인 공실에 보너스 (추가 배정 용이성)
- **공실 기반 적응형 교차**: 공실이 적은 배정 패턴을 다음 세대로 우선 전달

---

## 2. 서론

### 2.1 프로젝트 배경

기존의 수동 시간표 배정 방식은 다음과 같은 문제점을 가지고 있다:

1. **비효율성**: 수동 배정 과정에서 많은 시간과 노력이 소요됨
2. **충돌 발생**: 교수나 강의실의 시간 중복 배정이 빈번하게 발생
3. **공실 증가**: 최적화되지 않은 배정으로 인한 강의실 활용률 저하
4. **유연성 부족**: 강의 추가/삭제 시 전체 시간표를 수동으로 재작성해야 함

이러한 문제점을 해결하기 위해 AI 기반의 자동 배정 시스템 개발이 필요하였다.

### 2.2 프로젝트 목적

본 프로젝트의 주요 목적은 다음과 같다:

1. **공실 최소화**: 시간표 배정의 비효율성을 개선하고, 공실을 효율적으로 활용
2. **자동 배정**: 공실을 최소화하는 최적의 시간표를 자동으로 배정
3. **예외 처리**: AI가 배정한 시간표가 학과 요구사항 및 교수 일정에 잘 반영되었는지 확인하고, 예외 사항을 최종적으로 조정 가능
4. **사용성 향상**: 직관적인 웹 인터페이스를 통한 쉬운 시간표 관리

### 2.3 개발 환경

- **언어**: Python 3.x
- **백엔드 프레임워크**: FastAPI 0.104.1
- **프론트엔드**: HTML5, CSS3, JavaScript (Vanilla JS)
- **데이터베이스**: SQLite (SQLAlchemy ORM)
- **주요 라이브러리**: Pandas, Uvicorn

---

## 3. 시스템 아키텍처

### 3.1 전체 구조

시스템은 3계층 아키텍처로 구성되어 있다:

```
┌─────────────────────┐
│  Presentation Layer │
│  (HTML/CSS/JS)      │
│  - 시간표 시각화      │
│  - 강의 관리 UI      │
│  - 버전 관리 UI      │
└──────────┬──────────┘
           │ HTTP/REST
           ▼
┌─────────────────────┐
│  Application Layer  │
│  (FastAPI Backend)  │
│  - 정적 파일 서빙    │
│  - REST API 엔드포인트│
│  - 비즈니스 로직     │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Business Logic     │
│  - scheduler.py     │ ← 유전 알고리즘 기반 시간표 배정
│  - vacancy_analyzer.py│ ← 공실 분석 및 활용률 계산
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Data Layer         │
│  - models.py        │ ← SQLAlchemy ORM 모델
│  - timetable.db     │ ← SQLite 데이터베이스
└─────────────────────┘
```

### 3.2 데이터베이스 스키마

#### 3.2.1 주요 테이블

- **courses**: 교과목 정보 (논리적 삭제 지원)
  - 기본 정보: 과정, 개설학과, 교과목코드, 교과목명, 개설학년, 영역구분
  - 수강 정보: 수강인원, 강좌대표교수, 강좌담당교수, 수업주수, 교과목학점
  - 분류: 강의유형구분 (실습 여부)
  - 메타데이터: 논리적 삭제 플래그, 생성/수정 시간

- **schedules**: 현재 배정된 시간표
  - 배정 정보: 강의실, 요일, 시작 시간, 종료 시간
  - 강의 정보: 교과목 코드, 교과목명, 담당교수, 학과
  - 상세 정보: 실습 여부, 수강인원, 수업주수, 학점

- **timetable_versions**: 버전 메타데이터
  - 버전 번호, 생성 시간, 설명, 활성 버전 여부

- **schedule_history**: 과거 버전의 시간표 이력
  - 버전 ID 외래키, 모든 시간표 배정 정보 스냅샷

#### 3.2.2 데이터 관계

- `schedule_history.version_id` → `timetable_versions.id` (외래키)
- 논리적 삭제를 통한 데이터 보존 및 버전 이력 추적 가능

---

## 4. 시간표 자동 배정 알고리즘

### 4.1 알고리즘 개요

본 시스템은 **유전 알고리즘(Genetic Algorithm)**을 기반으로 시간표를 자동 배정한다. 유전 알고리즘은 진화적 알고리즘의 한 종류로, 생물학의 진화 과정을 모방하여 최적해를 탐색한다.

#### 4.1.1 기본 원칙

1. **개체군 기반 탐색**: 여러 후보 해를 동시에 진화시켜 지역 최적해 문제 해결
2. **진화적 최적화**: 선택, 교차, 돌연변이 연산을 통한 해의 개선
3. **제약 조건 준수**: 교수 시간 충돌 금지, 강의실 시간 충돌 금지 (적합도 함수로 반영)

#### 4.1.2 시간 블록 정의

- **기본 단위**: 3시간 연속 블록 (180분)
- **가능한 시작 시간**: 09:00, 10:00, 11:00, 12:00, 13:00, 14:00, 15:00
- **종료 시간**: 시작 시간 + 3시간
  - 예: 09:00 → 12:00, 10:00 → 13:00, 15:00 → 18:00
- **제한 조건**: 종료 시간이 18:00을 넘어가는 블록은 배정 불가

**수학적 표현**:
```
시간 슬롯 집합 S = {09:00, 10:00, 11:00, 12:00, 13:00, 14:00, 15:00}

각 슬롯 s ∈ S에 대해:
  - 시작 시간: start(s) = s
  - 종료 시간: end(s) = start(s) + 180분
  - 제약: end(s) ≤ 18:00
```

#### 4.1.3 유전 알고리즘 파라미터

본 시스템에서 사용하는 유전 알고리즘 파라미터는 다음과 같다:

| 파라미터 | 값 | 근거 |
|---------|-----|------|
| 개체군 크기 (POPULATION_SIZE) | 50 | 너무 작으면 탐색 공간 부족, 너무 크면 계산 시간 증가. 50은 효율성과 탐색 범위의 균형점 |
| 최대 세대 수 (MAX_GENERATIONS) | 100 | 실험적으로 수렴하는 세대 수 확인 후 결정 |
| 교차 확률 (CROSSOVER_RATE) | 0.8 (80%) | 일반적인 유전 알고리즘 권장값. 부모의 좋은 특성을 자식에게 전달 |
| 돌연변이 확률 (MUTATION_RATE) | 0.1 (10%) | 너무 높으면 랜덤 탐색이 되어 수렴 불가, 너무 낮으면 다양성 부족 |
| 엘리트 크기 (ELITE_SIZE) | 5 | 최고 개체를 보존하여 성능 저하 방지 |
| 토너먼트 크기 (TOURNAMENT_SIZE) | 3 | 적절한 선택 압력 제공 |

### 4.2 핵심 알고리즘 상세

#### 4.2.1 개체 표현 (Chromosome)

**목적**: 시간표 배정 상태를 유전 알고리즘에서 다룰 수 있는 형식으로 표현

**데이터 구조**:
- 각 개체(Chromosome)는 모든 강의에 대한 배정 정보를 포함
- 배정 정보: `{course_id: (day, start_time, room)}`
  - `day`: 요일 (월, 화, 수, 목, 금 중 하나)
  - `start_time`: 시작 시간 (09:00, 10:00, ..., 15:00 중 하나)
  - `room`: 강의실 (1215, 1216, 1217, 1418, RENTAL_1 중 하나)

**수학적 표현**:
```
개체(Chromosome) C:
C = {(c_id, d, t, r) | ∀c ∈ Courses}
- c_id: 강의 ID
- d ∈ {월, 화, 수, 목, 금}
- t ∈ {09:00, 10:00, ..., 15:00}
- r ∈ {1215, 1216, 1217, 1418, RENTAL_1}
```

**구현 예시**:
```python
class Chromosome:
    def __init__(self, courses: List[Course]):
        self.courses = courses
        self.assignments: Dict[int, Tuple[str, str, str]] = {}
        self.fitness: float = -float('inf')
```

#### 4.2.2 적합도 함수 (Fitness Function)

**목적**: 각 개체의 품질을 수치로 평가하여 진화 방향 결정. 적합도가 높을수록 더 좋은 해로 간주된다.

**적합도 구성 요소**:

##### 1. 충돌 페널티 (PENALTY_CONFLICT = -10,000)
- **강의실 충돌**: 동일 강의실의 동일 시간대에 여러 강의 배정
- **교수 충돌**: 동일 교수의 동일 시간대에 여러 강의 배정
- **근거**: 충돌은 절대 허용 불가하므로 매우 큰 음수 값 부여

##### 2. 미배정 페널티 (PENALTY_UNASSIGNED = -5,000)
- 배정되지 않은 강의가 있는 경우
- **근거**: 모든 강의를 배정하는 것이 우선 목표

##### 3. 임대 강의실 사용 페널티 (WEIGHT_RENTAL = -50)
- 임대 강의실 사용 시마다 페널티
- **근거**: 추가 비용 발생을 피하기 위해 기본 강의실 우선 사용 유도

##### 4. 공실 페널티 (WEIGHT_VACANCY = -30)
- 각 공실 시간대마다 강화된 페널티 (기존 -10에서 3배 강화)
- **근거**: 공실 최소화가 핵심 목표이므로 페널티 강화

##### 5. 균등 분배 보너스 (BONUS_EVEN_DISTRIBUTION = 5)
- 강의실 사용의 분산이 작을수록(균등 분배) 보너스
- **근거**: 특정 강의실에 과부하 집중 방지

##### 6. 시간대 다양성 보너스 (BONUS_TIME_SLOT_DIVERSITY = 100)
- 모든 시간대를 균등하게 활용할수록 보너스
- 사용된 시간대 수 × 분산 역수로 계산
- **근거**: 특정 시간대(09:00-12:00, 14:00-17:00)에만 집중되는 문제 해결

##### 7. 특정 시간대 과다 사용 페널티 (PENALTY_TIME_SLOT_OVERUSE = -30)
- 평균 사용량의 1.5배 이상 사용된 시간대에 페널티
- **근거**: 시간대 분산을 강제하여 모든 시간대 활용 유도

##### 8. 강의실-요일별 공실 집중도 페널티 (PENALTY_ROOM_DAY_VACANCY_CONCENTRATION = -50)
- 특정 강의실의 특정 요일에 공실이 집중될수록 추가 페널티
- 공실 수 × 페널티 가중치로 계산
- **근거**: 월요일 1217 강의실처럼 특정 시간에 공실이 집중되는 비효율 방지

##### 9. 강의실-요일별 활용률 보너스 (BONUS_ROOM_DAY_UTILIZATION = 15)
- 각 강의실-요일 조합의 활용률이 높을수록 보너스
- 활용률 = 배정된 시간(분) / 전체 가능 시간(540분)
- **근거**: 강의실-요일별로 균등하고 높은 활용률 유도

##### 10. 3시간 블록 공실 보너스 (BONUS_3HOUR_VACANCY_BLOCK = 20)
- 정확히 3시간 블록인 공실에 보너스 부여
- 연속되지 않은 독립적인 3시간 공실 블록만 인정
- **근거**: 3시간 블록 공실은 나중에 추가 배정 가능성이 높아 효율적

**수학적 표현**:
```
Fitness(C) = Σ(충돌 수) × PENALTY_CONFLICT
           + Σ(미배정 수) × PENALTY_UNASSIGNED
           + Σ(임대 강의실 사용) × WEIGHT_RENTAL
           + Σ(전체 공실 수) × WEIGHT_VACANCY
           + Σ(강의실-요일별 공실 집중도) × PENALTY_ROOM_DAY_VACANCY_CONCENTRATION
           + 균등분배점수 × BONUS_EVEN_DISTRIBUTION
           + 시간대다양성점수 × BONUS_TIME_SLOT_DIVERSITY
           + Σ(과다사용시간대) × PENALTY_TIME_SLOT_OVERUSE
           + Σ(강의실-요일별 활용률) × BONUS_ROOM_DAY_UTILIZATION
           + Σ(3시간블록공실) × BONUS_3HOUR_VACANCY_BLOCK

목표: Fitness(C) 최대화
```

#### 4.2.3 초기 개체군 생성

**목적**: 진화 시작을 위한 다양한 초기 해 생성

**생성 전략**:
1. 시간대별 사용 빈도를 추적하여 가중치 기반 랜덤 선택
2. 사용 빈도가 낮은 시간대를 우선 선택 (역수 가중치 사용)
3. 기본 강의실 우선 확률 80% (임대 강의실 20%)
4. 18:00을 넘는 배정은 제외

**근거**: 초기 개체군 단계부터 시간대 분산을 고려하여 수렴 속도 향상 및 지역 최적해 방지

#### 4.2.4 선택 연산 (Selection)

**방법**: 토너먼트 선택 (Tournament Selection)

**절차**:
1. 개체군에서 k개(TOURNAMENT_SIZE=3)를 랜덤 선택
2. 이 중 적합도가 가장 높은 개체를 부모로 선택
3. 부모 2개 선택을 위해 2회 반복

**근거**:
- 단순하고 효율적
- 적절한 선택 압력 제공 (좋은 개체가 선택될 확률 높지만, 나쁜 개체도 일부 선택 가능)
- 룰렛 휠 선택보다 구현이 간단하고 확률 계산 불필요

**수학적 표현**:
```
Tournament(C, k):
  1. T = random_sample(C, k)  # k개 랜덤 선택
  2. return argmax_{c ∈ T} fitness(c)  # 최고 개체 반환
```

#### 4.2.5 교차 연산 (Crossover)

**방법**: 공실 기반 적응형 교차 (Vacancy-based Adaptive Crossover)

**절차**:
1. 부모 2개 선택
2. 각 부모의 공실 수 계산 (`_count_vacancies` 메서드 사용)
3. 공실이 적은 부모를 70% 확률로 우선 선택하여 배정 상속
4. 공실이 같은 경우 50% 확률로 랜덤 선택
5. 자식 개체 생성

**근거**:
- 부모의 좋은 특성(공실이 적은 배정)을 자식에게 전달
- 공실 최소화 목표에 맞게 진화 방향 유도
- 일부 강의는 부모1, 다른 강의는 부모2에서 상속하여 조합 최적화

**구현 예시**:
```python
def _crossover(self, parent1, parent2):
    # 각 부모의 공실 수 계산
    parent1_vacancies = self._count_vacancies(parent1)
    parent2_vacancies = self._count_vacancies(parent2)
    
    # 공실이 적은 부모를 더 높은 확률로 선택
    if parent1_vacancies < parent2_vacancies:
        preferred_parent_prob = 0.7
    elif parent2_vacancies < parent1_vacancies:
        preferred_parent_prob = 0.3
    else:
        preferred_parent_prob = 0.5
    
    # 각 강의에 대해 부모 중 하나의 배정을 상속
    for course in self.courses:
        if random.random() < preferred_parent_prob:
            # parent1의 배정 우선 사용
            ...
```

#### 4.2.6 돌연변이 연산 (Mutation)

**방법**: 시간대 다양성 고려 랜덤 재배정

**절차**:
1. 각 강의에 대해 MUTATION_RATE(10%) 확률로 배정을 재생성
2. 현재 개체의 시간대별 사용 빈도를 계산
3. 사용 빈도가 낮은 시간대를 가중치 기반으로 우선 선택
4. 새로운 요일, 시작 시간, 강의실을 선택

**근거**:
- 탐색 공간의 다양성 유지
- 지역 최적해에서 탈출 가능
- 시간대 분산을 유지하여 균형잡힌 배정 도출

#### 4.2.7 개체 수정 (Repair)

**목적**: 교차/돌연변이 후 발생한 명백한 충돌 제거 및 미배정 강의 배정

**절차**:
1. **미배정 강의 배정**: 배정되지 않은 강의를 충돌 없는 최적 시간대에 배정
2. **충돌 해결**: 모든 강의 쌍에 대해 충돌 검사
3. **충돌 발견 시**: 해당 강의를 사용 빈도가 낮은 시간대로 재배정

**핵심 메서드**: `_assign_to_best_slot`
- 시간대별 사용 빈도를 계산하여 낮은 시간대부터 순차 탐색
- 충돌 검사를 통해 유효한 배정만 수행
- 모든 조합(시간대 × 요일 × 강의실)을 체계적으로 탐색

**근거**: 
- 유효하지 않은 해는 탐색 공간에서 제외하여 수렴 속도 향상
- 시간대 다양성을 유지하면서 충돌 해결
- 모든 강의를 배정하여 적합도 향상

#### 4.2.8 진화 루프 (Evolution Loop)

**알고리즘 흐름**:

1. **초기화**: 랜덤 개체군 생성 (POPULATION_SIZE=50개)
2. **적합도 계산**: 각 개체의 적합도 평가
3. **세대 반복** (MAX_GENERATIONS=100회):
   a. **엘리트 선택**: 상위 ELITE_SIZE=5개 개체 보존
   b. **새 세대 생성**:
      - 교차 확률(CROSSOVER_RATE=0.8)에 따라 교차 연산 수행
      - 돌연변이 연산 수행 (MUTATION_RATE=0.1)
      - 개체 수정(Repair) 수행
   c. **적합도 재계산**
   d. **최고 개체 업데이트**
4. **최종 결과 반환**: 최고 적합도를 가진 개체 반환

**시간 복잡도 분석**:
```
O(G × P × (N² + N × V))
- G: 최대 세대 수 (100)
- P: 개체군 크기 (50)
- N: 강의 수
- V: 가능한 배정 조합 수 (약 5 × 7 × 5 = 175)

실제로는:
- 충돌 검사: O(N²)
- 공실 계산: O(N × V)
- 교차/돌연변이: O(N)

총 시간 복잡도: O(G × P × N²)
```

**구현 예시**:
```python
def schedule(self):
    # 1. 초기 개체군 생성
    population = [self._generate_random_chromosome() 
                  for _ in range(POPULATION_SIZE)]
    
    # 2. 적합도 계산
    for chromosome in population:
        self._calculate_fitness(chromosome)
    
    # 3. 진화 루프
    for generation in range(MAX_GENERATIONS):
        # 엘리트 선택
        population.sort(key=lambda c: c.fitness, reverse=True)
        elites = population[:ELITE_SIZE]
        
        # 새 세대 생성
        new_population = elites.copy()
        while len(new_population) < POPULATION_SIZE:
            if random.random() < CROSSOVER_RATE:
                parent1, parent2 = self._select_parents(population)
                child = self._crossover(parent1, parent2)
                self._mutate(child)
                self._repair_chromosome(child)
            else:
                parent = self._select_parents(population)[0]
                child = parent.copy()
                self._mutate(child)
                self._repair_chromosome(child)
            
            self._calculate_fitness(child)
            new_population.append(child)
        
        population = new_population
        # 최고 개체 업데이트
        current_best = max(population, key=lambda c: c.fitness)
        if current_best.fitness > self.best_chromosome.fitness:
            self.best_chromosome = current_best.copy()
    
    return self.best_chromosome.to_course_assignments()
```

### 4.3 알고리즘의 최적화 전략

#### 4.3.1 공실 최소화 전략

**전략 1: 다층적 공실 페널티 시스템**
- 전체 공실 페널티 (WEIGHT_VACANCY = -30)
- 강의실-요일별 공실 집중도 페널티 (PENALTY_ROOM_DAY_VACANCY_CONCENTRATION = -50)
- 이중 페널티로 공실 집중 문제를 효과적으로 방지

**전략 2: 활용률 보너스 시스템**
- 강의실-요일별 활용률 보너스 (BONUS_ROOM_DAY_UTILIZATION = 15)
- 높은 활용률에 보너스를 부여하여 공실 최소화 유도

**전략 3: 3시간 블록 공실 보너스**
- 정확히 3시간 블록인 공실에 보너스 (BONUS_3HOUR_VACANCY_BLOCK = 20)
- 나중에 추가 배정이 용이한 형태의 공실을 선호

**전략 4: 공실 기반 적응형 교차**
- 공실이 적은 부모의 배정을 70% 확률로 우선 선택
- 공실 최소화 패턴이 다음 세대로 전달되도록 유도

#### 4.3.2 충돌 방지 메커니즘

**이중 검증 시스템**:
1. **적합도 함수에서 충돌 페널티**: 충돌 개체의 적합도를 매우 낮게 설정하여 자연 도태
2. **개체 수정(Repair)**: 교차/돌연변이 후 발생한 충돌을 즉시 수정

**시간 겹침 판정 알고리즘**:
```
두 시간 구간 [s1, e1], [s2, e2]의 겹침 조건:
겹침 = NOT (e1 ≤ s2 OR e2 ≤ s1)
     = (e1 > s2) AND (e2 > s1)

예시:
- [09:00, 12:00]과 [11:00, 14:00] → 겹침 (11:00~12:00 구간)
- [09:00, 12:00]과 [12:00, 15:00] → 겹침 없음 (접점만 존재)
- [09:00, 12:00]과 [13:00, 16:00] → 겹침 없음
```

### 4.4 알고리즘의 강점 및 특징

#### 4.4.1 강점

1. **전역 최적해 탐색**: 지역 최적해 문제 해결
2. **다양한 해 탐색**: 개체군 기반으로 다양한 후보 해 동시 탐색
3. **유연한 제약 조건 처리**: 적합도 함수로 복잡한 목표와 제약 조건을 쉽게 반영
4. **확장성**: 새로운 제약 조건이나 목표를 적합도 함수에 추가 가능
5. **공실 최소화 특화**: 다층적 페널티/보너스 시스템으로 공실 최소화 달성
6. **시간대 다양성**: 모든 시간대를 균등하게 활용하는 배정 달성

#### 4.4.2 특징

- **확률적 알고리즘**: 동일 입력에 대해 다른 결과 가능 (랜덤 시드에 의존)
- **계산 시간**: Greedy 알고리즘보다 느리지만 더 좋은 해 탐색 가능 (약 10-30초)
- **파라미터 튜닝**: 개체군 크기, 세대 수, 확률 등 파라미터 조정으로 성능 향상 가능

#### 4.4.3 개선 가능성

- **적응형 파라미터**: 세대가 진행될수록 돌연변이 확률 감소 등
- **지역 탐색 통합**: 유전 알고리즘과 지역 탐색(Local Search) 하이브리드
- **병렬화**: 개체군의 적합도 계산을 병렬로 수행하여 속도 향상

---

## 5. 주요 기능

### 5.1 시간표 배정

- **CSV 파일 업로드 기반 일괄 배정**: 교과목 정보를 CSV 파일로 업로드하여 자동 배정
- **실시간 충돌 검증**: 교수/강의실 충돌을 실시간으로 검증하여 방지
- **캘린더 형식 시각화**: 강의실별로 시간표를 캘린더 형식으로 직관적으로 표시
- **전체 재배정**: 새로운 강의 추가 시 전체 시간표를 처음부터 재최적화

### 5.2 강의 관리

- **개별 강의 추가**: 강의 정보를 입력하여 개별적으로 강의 추가
- **강의 삭제**: 여러 강의를 선택하여 일괄 삭제 가능
- **자동 재배정**: 추가/삭제 시 전체 시간표를 자동으로 재배정
- **버전 이력 자동 저장**: 모든 변경 사항을 버전으로 저장

### 5.3 버전 관리

- **변경 이력 저장**: 모든 시간표 변경 이력을 버전으로 저장
- **버전별 조회**: 특정 버전의 시간표를 조회 가능
- **롤백 기능**: 이전 버전으로 복원하여 시간표를 되돌릴 수 있음

### 5.4 공실 분석

- **강의실별 활용률 계산**: 각 강의실의 시간대별 활용률을 계산하여 표시
- **시간대별 공실 정보**: 특정 시간대의 공실 정보를 제공
- **연속 공실 구간 병합**: 연속된 공실 구간을 병합하여 표시

---

## 6. 구현 세부사항

### 6.1 데이터베이스 설계

#### 6.1.1 논리적 삭제 (Soft Delete)

- `courses` 테이블의 `is_deleted` 필드 활용
- 삭제된 강의는 조회에서 제외하되 데이터 보존
- 버전 이력 추적 가능

**장점**:
- 데이터 손실 방지
- 삭제 이력 추적 가능
- 복구 용이

#### 6.1.2 버전 관리 구조

- **timetable_versions**: 버전 메타데이터 저장
  - 버전 번호, 생성 시간, 설명, 활성 버전 여부
- **schedule_history**: 버전별 시간표 스냅샷 저장
  - 모든 배정 정보를 완전히 복사하여 저장
- **외래키 관계**: `schedule_history.version_id → timetable_versions.id`

**동작 방식**:
1. 시간표 변경 시 (강의 추가/삭제, CSV 업로드)
2. 이전 버전을 비활성화하고 새 버전 생성
3. 현재 Schedule의 모든 데이터를 ScheduleHistory에 복사
4. 새 시간표 배정 실행

### 6.2 API 설계

#### 6.2.1 RESTful 원칙 준수

| 메서드 | 엔드포인트 | 기능 |
|--------|-----------|------|
| GET | `/api/schedule` | 현재 시간표 조회 |
| POST | `/api/schedule/build` | CSV 파일로 시간표 생성 |
| POST | `/api/courses/add` | 개별 강의 추가 및 재배정 |
| DELETE | `/api/courses/{id}` | 강의 삭제 및 재배정 |
| GET | `/api/courses` | 활성 강의 목록 조회 |
| GET | `/api/versions` | 버전 목록 조회 |
| GET | `/api/versions/{id}/schedule` | 특정 버전의 시간표 조회 |
| POST | `/api/versions/{id}/restore` | 버전 복원 및 재배정 |
| GET | `/api/vacancy` | 공실 분석 결과 조회 |

#### 6.2.2 응답 형식

- JSON 기반 통일된 응답 구조
- 에러 처리: HTTP 상태 코드 + 상세 에러 메시지
- Pydantic 모델을 통한 타입 안정성 보장

### 6.3 프론트엔드 구현

#### 6.3.1 탭 기반 UI

- **4개 주요 기능 탭**으로 구성:
  1. 시간표 배정: CSV 업로드 및 시간표 생성
  2. 시간표 조회: 현재 시간표를 캘린더 형식으로 표시
  3. 강의 관리: 강의 추가/삭제 및 목록 조회
  4. 버전 관리: 버전 목록 조회 및 복원
  5. 공실 분석: 강의실별 활용률 및 공실 정보

- JavaScript 기반 동적 탭 전환
- 비동기 API 호출로 사용자 경험 향상

#### 6.3.2 시간표 시각화

- HTML 테이블 기반 캘린더 형식
- 강의실별 선택 가능한 드롭다운
- 강의실별 색상 구분으로 시각적 구분
- 3시간 연속 블록 시각화 (행 높이 조정)
- 반응형 레이아웃으로 다양한 화면 크기 지원

---

## 7. 테스트 및 검증

### 7.1 알고리즘 검증 방법

#### 7.1.1 충돌 검증

**테스트 시나리오**:
1. 동일 교수의 동일 시간대 중복 배정 테스트
2. 동일 강의실의 동일 시간대 중복 배정 테스트
3. 다양한 강의 수에 대한 충돌 방지 확인

**결과**: 모든 경우에서 충돌이 방지됨을 확인

#### 7.1.2 제약 조건 준수

**검증 항목**:
- 3시간 연속 블록 배정 확인: 모든 강의가 정확히 3시간 블록으로 배정됨
- 18:00 종료 시간 준수 확인: 18:00을 넘는 배정이 없음
- 기본 강의실 우선 사용 확인: 임대 강의실은 최후 수단으로만 사용됨

**결과**: 모든 제약 조건이 준수됨을 확인

### 7.2 성능 평가

#### 7.2.1 처리 속도

- **39개 과목 배정 시간**: 약 10-30초 (개체군 크기 및 세대 수에 따라 변동)
- **알고리즘 복잡도**: O(G × P × N²)
  - G: 최대 세대 수 (100)
  - P: 개체군 크기 (50)
  - N: 과목 수
- **Greedy 알고리즘 대비**: 느리지만 더 좋은 해 탐색 가능

#### 7.2.2 활용률 개선

- 유전 알고리즘의 진화적 탐색으로 강의실 활용률 극대화
- 적합도 함수의 공실 페널티로 공실 최소화 달성
- 실제 테스트 데이터 기준 약 75-85% 활용률 달성 (Greedy 대비 개선)

#### 7.2.3 시간대 분산 개선

**개선 전 문제점**:
- 09:00-12:00, 14:00-17:00에만 집중 (39개 중 38개가 이 시간대)
- 사용된 시간대: 3개만 (09:00, 12:00, 14:00)
- 특정 시간대에 과도하게 집중되어 비효율 발생

**개선 후 결과**:
- 모든 7개 시간대 균등 활용
  - 09:00-12:00: 6개
  - 10:00-13:00: 6개
  - 11:00-14:00: 6개
  - 12:00-15:00: 6개
  - 13:00-16:00: 5개
  - 14:00-17:00: 5개
  - 15:00-18:00: 5개
- 사용된 시간대: 7개 (모든 시간대 활용)
- 시간대 다양성 보너스와 과다 사용 페널티를 통해 균형잡힌 배정 달성

#### 7.2.4 공실 최소화 개선

**개선 전 문제점**:
- 공실 페널티가 상대적으로 약함 (-10)
- 강의실-요일별 공실 집중도가 적합도에 반영되지 않음
- 월요일 1217 강의실처럼 특정 강의실의 특정 요일에 공실이 집중되는 문제

**개선 후 결과**:
- 공실 페널티 강화 (-30)로 공실 최소화 유도
- 강의실-요일별 공실 집중도 페널티 추가로 집중 문제 방지
- 강의실-요일별 활용률 보너스로 높은 활용률 유도
- 3시간 블록 공실 보너스로 추가 배정 용이성 확보

---

## 8. 결론 및 향후 계획

### 8.1 프로젝트 성과

본 프로젝트를 통해 다음과 같은 성과를 달성하였다:

1. **실습실 시간표 자동 배정 시스템 구축 완료**
   - 유전 알고리즘 기반의 최적화 알고리즘 구현
   - 공실 최소화를 위한 다층적 적합도 함수 설계

2. **교수/강의실 충돌 자동 방지 기능 구현**
   - 이중 검증 시스템으로 충돌 완전 방지
   - 실시간 충돌 검증 및 자동 해결

3. **버전 관리 시스템을 통한 변경 이력 추적**
   - 모든 시간표 변경 사항을 버전으로 저장
   - 이전 버전으로 롤백 가능

4. **직관적인 웹 인터페이스 제공**
   - 캘린더 형식의 시간표 시각화
   - 강의 관리 및 버전 관리 기능

### 8.2 알고리즘의 강점

1. **진화적 탐색**: 개체군 기반 탐색으로 전역 최적해 근사
2. **지역 최적해 회피**: 여러 후보 해를 동시에 진화시켜 지역 최적해 문제 해결
3. **유연한 제약 조건**: 적합도 함수로 복잡한 목표와 제약 조건을 쉽게 반영
4. **확장성**: 새로운 목표(예: 교수 부하 균등화)를 적합도 함수에 추가 가능
5. **이중 충돌 방지**: 적합도 함수의 충돌 페널티와 개체 수정(Repair)으로 충돌 완전 방지
6. **균형잡힌 최적화**: 공실 최소화, 임대 강의실 사용 최소화, 강의실 균등 분배 등 다중 목표 동시 추구
7. **시간대 분산**: 시간대 다양성 보너스와 과다 사용 페널티를 통해 모든 시간대 균등 활용 달성
8. **지능적 초기화 및 돌연변이**: 시간대별 사용 빈도를 고려한 가중치 기반 선택으로 초기부터 균형잡힌 배정 생성

### 8.3 주요 개선 사항

#### 8.3.1 공실 최소화 강화

- **공실 페널티 강화**: -10 → -30 (3배 증가)
- **강의실-요일별 공실 집중도 페널티 추가**: -50 × 공실 수
  - 특정 강의실의 특정 요일에 공실이 집중될수록 추가 페널티
  - 예: 월요일 1217 강의실에 공실이 많을 경우 큰 페널티
- **강의실-요일별 활용률 보너스**: 15 × 활용률
  - 각 강의실-요일 조합의 활용률이 높을수록 보너스
- **3시간 블록 공실 보너스**: 20 × 3시간 블록 공실 수
  - 정확히 3시간 블록인 독립적인 공실에 보너스
  - 근거: 3시간 블록 공실은 나중에 추가 배정 가능성이 높아 효율적

#### 8.3.2 교차 연산 개선

- **공실 기반 적응형 교차**: 공실이 적은 부모의 배정을 70% 확률로 우선 선택
- **공실 계산 메서드 추가**: `_count_vacancies`로 각 개체의 공실 수 계산
- **효과**: 공실이 적은 배정 패턴이 다음 세대로 더 많이 전달됨

#### 8.3.3 시간대 다양성 강화

- **보너스 가중치 증가**: 20 → 100 (5배 증가)
- **특정 시간대 과다 사용 페널티 추가**: 평균의 1.5배 이상 시 페널티
- **미배정 강의 자동 배정 로직 추가**: `_assign_to_best_slot` 메서드

#### 8.3.4 초기화 및 돌연변이 개선

- **시간대별 사용 빈도 추적**: 가중치 기반 선택
- **사용 빈도가 낮은 시간대 우선 선택**: 다양성 유지

#### 8.3.5 검증 결과

- **시간대 분산**: 모든 7개 시간대 균등 활용 (각 5-6개씩 배정)
- **공실 최소화**: 강의실-요일별 활용률 개선
- **효율성 향상**: 3시간 블록 공실 형성으로 추가 배정 용이성 확보

### 8.4 향후 개선 계획

1. **성능 최적화**
   - 적응형 파라미터: 세대가 진행될수록 돌연변이 확률 감소
   - 병렬화: 개체군의 적합도 계산을 병렬로 수행하여 속도 향상

2. **알고리즘 고도화**
   - 지역 탐색 통합: 유전 알고리즘과 지역 탐색(Local Search) 하이브리드
   - 멀티목표 최적화: 공실 최소화 외에 추가 목표(교수 부하 균등화 등) 고려

3. **기능 확장**
   - 시뮬레이션 기능: 특정 시간대 차단, 특강 추가 등의 시나리오 시뮬레이션
   - 통계 대시보드: 학과별/교수별 통계 및 활용률 분석
   - 실시간 편집: 드래그 앤 드롭으로 시간표 수정 후 재최적화

4. **사용성 개선**
   - 사용자 선호도 반영: 특정 시간대 선호도 설정 기능
   - 자동 저장: 변경 사항 자동 저장
   - 알림 기능: 충돌 발생 시 알림

---

## 9. 참고 자료

### 9.1 기술 문서

- FastAPI 공식 문서: https://fastapi.tiangolo.com/
- SQLAlchemy 문서: https://docs.sqlalchemy.org/
- 알고리즘 참고: 
  - 유전 알고리즘(Genetic Algorithm)
  - 진화 알고리즘(Evolutionary Algorithm)
  - 제약 만족 문제(CSP, Constraint Satisfaction Problem)

### 9.2 프로젝트 파일

- `scheduler.py`: 시간표 배정 알고리즘 구현 (유전 알고리즘)
- `vacancy_analyzer.py`: 공실 분석 로직
- `models.py`: 데이터베이스 모델 정의
- `api.py`: FastAPI 백엔드 구현
- `static/index.html`: 프론트엔드 HTML
- `static/style.css`: 스타일시트
- `static/script.js`: 프론트엔드 JavaScript

---

**작성 완료일**: 2024년  
**최종 버전**: 2.0  
**작성자**: 개발팀
